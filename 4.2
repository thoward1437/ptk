#!/bin/bash

# Automated Incident Response System (Bash version)
# Требования: Bash 4+, sudo для команд (iptables, kill и т.д.), mail для эскалации

LOG_FILE="logs/air_system.log"
declare -a rollback_stack  # Массив для отката

# Функция логирования
function log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE"
}

# Функция эскалации
function escalate() {
    local message="$1"
    local confidence="$2"
    log "warning" "Escalating due to low confidence ($confidence): $message"
    # Отправка email (требует настройки mail; замените на реальный адрес)
    echo "$message" | mail -s "AIR Escalation" operator@company.com 2>/dev/null || log "error" "Failed to send email"
}

# Функция выполнения действия с откатом
function execute_action() {
    local action="$1"
    shift
    log "info" "Executing action: $action with params: $@"
    case "$action" in
        block_ip)
            local ip="$1"
            sudo iptables -A INPUT -s "$ip" -j DROP
            rollback_stack+=("sudo iptables -D INPUT -s $ip -j DROP")
            ;;
        unblock_ip)
            local ip="$1"
            sudo iptables -D INPUT -s "$ip" -j DROP
            ;;
        isolate_process)
            local pid="$1"
            kill -STOP "$pid"  # Pause
            gcore "$pid" 2>/dev/null || log "error" "gcore failed for PID $pid"  # Memory dump
            rollback_stack+=("kill -CONT $pid")
            ;;
        resume_process)
            local pid="$1"
            kill -CONT "$pid"
            ;;
        quarantine_file)
            local file="$1"
            sudo mv "$file" "/quarantine/$(basename "$file")"
            rollback_stack+=("sudo mv /quarantine/$(basename "$file") $file")
            ;;
        restore_file)
            local file="$1"
            sudo mv "/quarantine/$(basename "$file")" "$file"
            ;;
        restore_from_backup)
            local file="$1"
            sudo cp "/backup/$(basename "$file")" "$file"
            ;;
        kill_process)
            local pid="$1"
            kill -9 "$pid"
            ;;
        block_pools)
            local pool="$1"
            echo "127.0.0.1 $pool" | sudo tee -a /etc/hosts >/dev/null
            rollback_stack+=("sudo sed -i '/127.0.0.1 $pool/d' /etc/hosts")
            ;;
        unblock_pools)
            local pool="$1"
            sudo sed -i "/127.0.0.1 $pool/d" /etc/hosts
            ;;
        notify)
            local msg="$1"
            log "info" "Notification: $msg"
            ;;
        *)
            log "error" "Unknown action: $action"
            return 1
            ;;
    esac
}

# Функция запуска плейбука
function run_playbook() {
    local playbook_file="$1"
    local context="$2"  # Простой формат: key=value,key2=value2
    local confidence="$3"

    # Загружаем плейбук
    source "$playbook_file" 2>/dev/null || { log "error" "Failed to load playbook: $playbook_file"; return 1; }

    log "info" "Running playbook: $PLAYBOOK_NAME"

    # Проверяем уверенность
    if (( $(echo "$confidence < $CONFIDENCE_THRESHOLD" | bc -l) )); then
        escalate "$PLAYBOOK_NAME" "$confidence"
        return  # Эскалация (ожидание подтверждения; в реальности можно добавить паузу)
    fi

    # Выполняем шаги (предполагаем функции step_1, step_2 и т.д.)
    local step_num=1
    while declare -f "step_$step_num" >/dev/null; do
        # Парсим контекст (простая подстановка)
        local params=""
        IFS=',' read -ra KV <<< "$context"
        for kv in "${KV[@]}"; do
            IFS='=' read -r key value <<< "$kv"
            params="$params $value"
        done
        "step_$step_num" $params
        ((step_num++))
    done
}

# Функция обнаружения и реагирования
function detect_and_respond() {
    local incident_type="$1"
    local context="$2"
    local confidence="${3:-1.0}"
    local playbook_file="playbooks/${incident_type}.sh"

    if [[ -f "$playbook_file" ]]; then
        run_playbook "$playbook_file" "$context" "$confidence"
    else

Андрюша 2, [29.11.2025 10:21]
log "error" "No playbook found for $incident_type"
    fi
}

# Функция отката
function rollback() {
    log "info" "Rolling back actions"
    for cmd in "${rollback_stack[@]}"; do
        log "info" "Rollback: $cmd"
        eval "$cmd"
    done
    rollback_stack=()  # Очищаем стек
}

# Пример использования (симуляция обнаружения инцидентов)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # Создаем карантин и backup папки, если нужно
    sudo mkdir -p /quarantine /backup

    detect_and_respond "brute_force" "ip=192.168.1.100" 0.9
    detect_and_respond "suspicious_process" "pid=1234" 0.7  # Эскалация
    detect_and_respond "critical_file_change" "file=/etc/passwd" 1.0
    detect_and_respond "crypto_miner" "pid=5678,pool=minerpool.com" 1.0

    # Пример отката (при false positive)
    rollback
fi
